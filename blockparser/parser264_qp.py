import re
import subprocess
import os
import json
import argparse
import sys
import gzip
import numpy as np
from typing import List, Dict, Tuple, Optional
from .utils import check_ffmpeg_in_path, get_framerate, parse_fps

# -----------------------------
# QP log parsing
# -----------------------------

def parse_qp_log(log_path: str) -> List[Dict]:
    """
    Parse the output generated by `ffmpeg -debug qp`.
    Returns a list of frame dicts
    """
    print("Parsing QP log file: ", log_path)
    frames = []
    current_frame = None
    parsing_started = False
    skip_next = False
    frame_idx = 0

    with open(log_path, 'r', errors='ignore') as f:
        for line in f:
            if not parsing_started:
                if "New frame, type: " in line:
                    parsing_started = True
                else:
                    continue

            if "New frame, type: " in line:
                if current_frame:
                    frames.append(current_frame)
                    frame_idx += 1

                match = re.search(r"New frame, type: (\w+)", line)
                frame_type = match.group(1) if match else "UNKNOWN"
                current_frame = {
                    'frame': frame_idx,
                    'type': frame_type,
                    'qp_grid': [],  #extra information that can be useful for debugging or future features
                    'status': 'VALID'
                }
                skip_next = True
                continue

            if skip_next:
                skip_next = False
                continue

            if any(s in line for s in ['nal_unit_type', 'detected', 'lavf', 'Stream', 'cur_dts']):
                continue

            parts = line.split(']', 1)
            content = parts[-1].strip() if len(parts) > 1 else line.strip()

            # Heuristic to detect lines containing qp grid numbers
            qp_values = []
            # Old ffmpeg format
            if re.match(r'^\s*\d{1,4}\s+', content):
                numbers = re.sub(r'^\s*\d+\s*', '', content)
                numbers = re.sub(r'\D', '', numbers)
                for i in range(0, len(numbers), 2):
                    qp = numbers[i:i+2]
                    if len(qp) == 2:
                        qp_values.append(int(qp)) 
            # New ffmpeg format
            elif re.search(r'\d{20,}', content):
                numbers = re.sub(r'\D', '', content)
                for i in range(0, len(numbers), 2):
                    qp = numbers[i:i+2]
                    if len(qp) == 2:
                        qp_values.append(int(qp))

            if qp_values and current_frame is not None:
                current_frame['qp_grid'].append(qp_values)
            elif current_frame is not None and current_frame['qp_grid']:
                current_frame['status'] = 'CORRUPTED'

        #leave this here for reference
        # if re.match(r'^\s*\d+\s+\d{2,}', content): 
        #     numbers = re.sub(r'^\s*\d+\s*', '', content) 
        #     numbers = re.sub(r'\D', '', numbers) 
        #     qp_values = [] 
        #     for i in range(0, len(numbers), 2): 
        #         qp = numbers[i:i+2] 
        #         if len(qp) == 2 and qp.isdigit(): 
        #             qp_values.append(int(qp)) 
                    
        #     if qp_values and current_frame is not None: 
        #         current_frame['qp_grid'].append(qp_values) 
        #     elif current_frame is not None and current_frame['qp_grid']: 
        #         current_frame['status'] = 'CORRUPTED'

        if current_frame:
            frames.append(current_frame)

    # Clean up statuses
    for frame in frames:
        frame.pop('status', None) #extra informazion removed because non used rn

    return frames


# -----------------------------
# QP generation (FFmpeg) -> log.txt
# -----------------------------

def generate_qp_from_video(
    input_video: str,
    log_path: str = "debug_frameqp.txt",
    ffmpeg_path: str = "ffmpeg"
) -> bool:
    """
    Generate QP debug log from input video (only H.264 is supported) using ffmpeg.
    """
    cmd = [
        ffmpeg_path,
        "-threads", "1",
        "-hide_banner",
        "-debug", "qp",
        "-i", input_video,
        "-f", "null",
        "-"
    ]
    print("Running ffmpeg to extract QP debug info. This can take a while, a long while (depends on the length of the video and there is not any progress bar).")
    with open(log_path, "w", encoding="utf-8") as logfile:
        result = subprocess.run(cmd, stdout=subprocess.DEVNULL, stderr=logfile)

    return os.path.isfile(log_path) and os.path.getsize(log_path) > 0

# -----------------------------
# Writeers (YUV/MKV/JSON)
# -----------------------------

def save_qp_report(
    frames: List[Dict],
    output_file: str,
    compression: bool
) -> Tuple[Dict, str]:
    """
    Save the parsed QP frames into a JSON file, optionally compressed with gzip.
    """
    stats = {
        'total': len(frames),
        'valid': len([f for f in frames if f.get('qp_grid')]),
        'empty': len([f for f in frames if not f.get('qp_grid')]),
    }
    report = {
        "info": stats,
        "frames": frames
    }
    if compression:
        gz_file = output_file + ".gz" if not output_file.endswith(".gz") else output_file
        with gzip.open(gz_file, 'wt', encoding='utf-8') as f:
            json.dump(report, f, separators=(',', ':'), ensure_ascii=False)
        return report, gz_file
    else:
        with open(output_file, 'w', encoding='utf-8') as f:
            json.dump(report, f, separators=(',', ':'), ensure_ascii=False)
        return report, output_file


def write_qp_to_yuv(
    frames: List[Dict],
    output_yuv_path: str
) -> None: #Use it if you want a raw YUV file instead of MKV (idk why would you want that)
    """
    Write the QP grids into a raw YUV400 file (8bit, 6bit effective) with no header.
    """
    if not frames:
        print("No frames to write!")
        return
    height = len(frames[0]['qp_grid'])
    width = len(frames[0]['qp_grid'][0])
    frame_size = width * height
    num_frames = len(frames)

    print(f"Writing {num_frames} frames to YUV400 (8bit, 6bit effective) -> {output_yuv_path}")
    with open(output_yuv_path, "wb") as f:
        f.write(b'\x00' * (frame_size * num_frames))

    with open(output_yuv_path, "r+b") as f:
        for frame in frames:
            qp_grid = np.array(frame['qp_grid'], dtype=np.uint8)
            qp_grid = np.clip(qp_grid, 0, 63)
            f.seek(frame['frame'] * frame_size)
            f.write(qp_grid.tobytes())


def write_qp_to_mkv(
    frames: List[Dict],
    output_mkv_path: str,
    fps: float,
    ffmpeg_path: str = "ffmpeg"
) -> None:
    """
    Write the QP grids into a MKV file using FFV1 codec (lossless).
    """
    if not frames:
        raise ValueError("No frames to write!")
    
    check_ffmpeg_in_path(ffmpeg_path)

    height = len(frames[0]['qp_grid'])
    width = len(frames[0]['qp_grid'][0])

    print(f"Writing {len(frames)} frames to temporary raw YUV file...")
    tmp_yuv = "tmp_qp.yuv" #no piping because is buggy
    with open(tmp_yuv, "wb") as f:
        for frame in frames:
            qp_grid = np.array(frame['qp_grid'], dtype=np.uint8)
            qp_grid = np.clip(qp_grid, 0, 63)
            f.write(qp_grid.tobytes())

    print(f"Encoding raw YUV into MKV with FFV1 -> {output_mkv_path}") #it's really fast
    cmd = [
        ffmpeg_path,
        "-y",
        "-f", "rawvideo",
        "-pixel_format", "gray",
        "-video_size", f"{width}x{height}",
        "-framerate", str(fps),
        "-color_range", "pc",
        "-i", tmp_yuv,
        "-c:v", "ffv1",
        "-color_range", "pc",
        output_mkv_path
    ]

    result = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
    if result.returncode != 0:
        print("FFmpeg error:\n", result.stderr)
    else:
        print(f"MKV generated successfully: {output_mkv_path}")

    try:
        os.remove(tmp_yuv)
    except OSError:
        pass


# -----------------------------
# VapourSynth API
# -----------------------------

def createQPNode(
    input_video: Optional[str] = None,
    frames: Optional[List[Dict]] = None,
    ffmpeg_path: Optional[str] = None,
    fps_num: Optional[int] = None,
    fps_den: Optional[int] = None,
    log_path: str = "debug_frameqp.txt"
) -> 'vs.VideoNode': # type: ignore
    """
    Create a VapourSynth VideoNode from parsed QP frames or by generating the log from a video or from an already genereted QP list.
    Either input_video or frames must be provided. If only log_path is provided, fps_num and fps_den must also be provided.

    :param input_video: Path to input video file (H.264 only)
    :param frames: List of parsed frames (from parse_qp_log)
    :param ffmpeg_path: Path to ffmpeg executable. Will use path if None (optional)
    :param fps_num: Frame rate numerator (required if only log_path is provided)
    :param fps_den: Frame rate denominator (required if only log_path is provided)
    :return: VapourSynth VideoNode with QP grids as GRAY8 format
    """
    import vapoursynth as vs
    core = vs.core

    ffmpeg_path_checked = check_ffmpeg_in_path(ffmpeg_path)

    def _frames_to_numpy(frames: List[Dict]) -> np.ndarray:
        if not frames:
            raise ValueError("No frames provided to frames_to_numpy")

        height = len(frames[0]['qp_grid'])
        width = len(frames[0]['qp_grid'][0])
        num_frames = len(frames)
        arr = np.zeros((num_frames, height, width), dtype=np.uint8)

        for f in frames:
            qp_grid = np.array(f['qp_grid'], dtype=np.uint8)
            qp_grid = np.clip(qp_grid, 0, 63)
            arr[f['frame']] = qp_grid

        return arr
    
    def numpy_to_frame(np_array: np.ndarray, blank_clip1: vs.VideoNode) -> vs.VideoFrame:
        """Convert a 2D NumPy array (float32) to a VapourSynth VideoFrame (GRAYS).

        Uses the provided implementation: copy a template frame and paste the array into plane 0.
        """
        assert np_array.ndim == 2 and np_array.dtype == np.uint8, "Input must be a 2D NumPy array of type uint8."

        frame = blank_clip1.get_frame(0).copy()
        np.copyto(np.asarray(frame[0]), np_array)
        return frame
    
    def check_if_parsedQP_exists(input_video: str) -> Tuple[int, str, str]:
        qp_txt_file = input_video.rsplit('.', 1)[0] + ".qp.txt" if '.' in input_video else input_video + ".qp.txt"
        if os.path.isfile(qp_txt_file) and os.path.getsize(qp_txt_file) > 0:
            return 1, qp_txt_file, input_video.rsplit('.', 1)[0] if '.' in input_video else input_video
        elif os.path.isfile(input_video) and os.path.getsize(input_video) > 0:
            return 2, input_video, input_video.rsplit('.', 1)[0] if '.' in input_video else input_video
        else:
            return 0, "", ""

    if frames is None:
        if input_video is not None:
            status, path, video_name = check_if_parsedQP_exists(input_video)
            fps , fps_num, fps_den= get_framerate(input_video)
            print(f"Detected FPS: {fps}")
            if status == 1:
                print(f"Using existing parsed QP log file: {path}")
                log_path = path
            elif status == 2:
                print(f"Input video provided, will generate QP log from: {path}")
                input_video = path
                ok = generate_qp_from_video(input_video, log_path=video_name + ".qp.txt", ffmpeg_path=ffmpeg_path_checked)
                if not ok:
                    raise RuntimeError("Failed to generate QP debug log from video")
            frames = parse_qp_log(log_path=video_name + ".qp.txt")
        elif log_path and os.path.isfile(log_path):
                print(f"Using existing parsed QP log file: {log_path}")
                if (fps_num is None or 0) and (fps_den is None or 0):
                    raise ValueError("When using only log_path, fps_num and fps_den must be provided")
                frames = parse_qp_log(log_path)
        else:
            raise ValueError("Either input_video or frames or log_path must be provided")

    if not frames:
        raise RuntimeError("No frames parsed to create VideoNode")

    print(f"Parsed {len(frames)} frames, converting to numpy array...")

    arr = _frames_to_numpy(frames)  # shape = (nframes, h, w)

    print(f"Numpy array shape: {arr.shape}, dtype: {arr.dtype}")

    nframes, h, w = arr.shape

    blank_template = core.std.BlankClip(length=1, width=w, height=h, format=vs.GRAY8)

    precomputed_frames = [None] * nframes
    for i in range(nframes):
        slice_i = np.ascontiguousarray(arr[i], dtype=np.uint8)
        precomputed_frames[i] = numpy_to_frame(slice_i, blank_template)

    base = core.std.BlankClip(length=nframes, width=w, height=h, format=vs.GRAY8, fpsnum=(fps_num or 1), fpsden=(fps_den or 1))

    def _selector(n, f, clips=None, _frames=precomputed_frames):
        return _frames[n]

    clip = core.std.ModifyFrame(base, clips=[base], selector=_selector)

    return clip


# -----------------------------
# CLI entrypoint
# -----------------------------

#TODO aggiornare il naming

def main_cli(argv=None):
    parser = argparse.ArgumentParser(description="Parse QP log, generate JSON or directly YUV/MKV file, or be used as a VapourSynth API module.")
    parser.add_argument('-v', '--video', type=str, help='Input video file')
    parser.add_argument('-l', '--log', type=str, help='Input QP log file')
    parser.add_argument('-o', '--output', type=str, default="qp_parsed_grid.json", help='Output JSON/YUV file')
    parser.add_argument('-c', '--compress', action='store_true', help='Use gzip for JSON output')
    parser.add_argument('-f', '--ffmpeg_path', type=str, default=None, help='Path to ffmpeg executable (optional)')
    parser.add_argument('-a', '--auto', action='store_true', help='If True, generates mkv file from QP grids (default False)')
    parser.add_argument('--fps', type=str, default=None, help='Frame rate to use for MKV (required if only log is provided)')

    args = parser.parse_args(argv)

    frames = None
    ffmpeg_path = None

    if args.ffmpeg_path:
        ffmpeg_path = check_ffmpeg_in_path(args.ffmpeg_path)

    if args.log:
        if args.fps:
            fps = parse_fps(args.fps)
            print(f"Using provided FPS: {fps}")
        else:
            print("Error: FPS must be provided if only log is given.")
            sys.exit(1)
        frames = parse_qp_log(args.log)
    elif args.video:
        fps = get_framerate(args.video)
        ffmpeg_path = check_ffmpeg_in_path(args.ffmpeg_path)
        if generate_qp_from_video(args.video, log_path="debug_frameqp.txt", ffmpeg_path=ffmpeg_path):
            frames = parse_qp_log("debug_frameqp.txt")
            try:
                os.remove("debug_frameqp.txt")
            except OSError:
                pass
        else:
            print(f"Failed to generate QP log from video: {args.video}")
            sys.exit(1)
    else:
        print("Provide at least a log (-l) or a video (-v)")
        sys.exit(1)

    if not frames:
        print("No frames parsed, aborting.")
        sys.exit(1)

    if args.auto:
        mkv_path = args.output if args.output.lower().endswith('.mkv') else args.output + ".mkv"
        fps_to_use = fps if 'fps' in locals() else (get_framerate(args.video) if args.video else None)
        if fps_to_use is None:
            print("FPS unknown, aborting MKV creation")
            sys.exit(1)
        if isinstance(fps_to_use, tuple):
            fps_to_use, _,  _ = fps_to_use
        else:
            fps_to_use = fps_to_use
        write_qp_to_mkv(frames, mkv_path, fps_to_use, ffmpeg_path=ffmpeg_path or 'ffmpeg')
        sys.exit(0)

    report, compressed_file = save_qp_report(frames, args.output, args.compress)
    print(f"QP grid generated as: {compressed_file}")


if __name__ == '__main__':
    main_cli()
